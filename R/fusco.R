fusco.test <- function(phy, dat = NULL, rich = NULL, tips = NULL, simulate=TRUE, sim.reps=1000, sim.CI = 0.95){        phy <- reorder(phy, "pruningwise")        if(! is.null(dat)){        # match the data in        if(! is.data.frame(dat)) stop("The object '", deparse(substitute(dat)),"' is not a data frame.")        rich <- deparse(substitute(rich))        if(! rich %in% names(dat)) stop("The column '", rich, "' was not found in '", deparse(substitute(dat)),",'.")        tips <- deparse(substitute(tips))        if(! tips %in% names(dat)) stop("The column '", tips, "' was not found in '", deparse(substitute(dat)),",'.")                       tipMatch <- match(phy$tip.label, dat[,tips])        if(any(is.na(tipMatch))) stop(paste(c("Missing species richness values for the following tips:", phy$tip.label[is.na(tipMatch)]), collapse="\n"))                rich <- dat[tipMatch, rich]        tipsAsSpecies <- FALSE    } else {        # assume that the tips are species        rich <- rep(1, length(phy$tip.label))        tipsAsSpecies <- TRUE    }    observed <- fusco.calc(phy, rich)    obsStats <- with(observed, c(median(I), IQR(I)/2))        ret <- list(observed=observed, median=median(observed$I), qd=IQR(observed$I)/2, tipsAsSpecies=tipsAsSpecies,                 nInformative=dim(observed)[1], nSpecies=sum(rich), nTips=length(rich))                    class(ret) <- "fusco"    if(simulate){        ret <- fusco.simulate(ret,  sim.reps, sim.CI)    }        return(ret)}fusco.calc <- function(phy, rich){    # OLD TO NEW CONVERTED    # rewritten by David Orme to use less expensive tree traversal    # assumes that fusco.test provides a vector of richnesses in the same tip order    # and that the tree is in pruningwise order        intNodes <- unique(phy$edge[,1])    nTip <- length(phy$tip.label)    nNode <- phy$Nnode    rich <- c(rich, rep(NA, nNode))        # Data store    tab <- data.frame(polytomy=logical(nNode), N1 = numeric(nNode),                      N2 = numeric(nNode), row.names=intNodes)        # loop tips    for(ind in seq(along=intNodes)){                # grab the daughters of the node        daughters <- phy$edge[,2][phy$edge[,1] == intNodes[ind]]        richD <- rich[daughters]                if(length(daughters) > 2){            tab$polytomy[ind] <- TRUE          } else {            tab[ind, 2:3] <- richD        }                rich[intNodes[ind]] <- sum(richD)    }        tab$S <- with(tab, N1 + N2)    tab <- subset(tab, ! polytomy & S > 3, select=-polytomy)        tab$B <- with(tab, pmax(N1, N2))    tab$M <- tab$S - 1    tab$m <- ceiling(tab$S/2)        tab$I <- with(tab, (B - m)/(M - m))    tab$S.odd <- (tab$S %% 2) == 1    tab$w <- with(tab, ifelse(S.odd, 1, ifelse(I > 0, M/S, 2*M/S)))     tab$I.w <- with(tab, (I*w)/mean(w))    tab$I.prime <- with(tab, ifelse(S.odd, I, I * M/S))    return(tab)}  fusco.simulate <- function(obj,  sim.reps=1000, sim.CI = 0.95){        # Think about which version of I to use    expFun <- function(nTips, nSpp){        nullTree <- fusco.null.tree(nTips, nSpp)        fuscoDist <- with(nullTree, fusco.calc(phy, rich))        ret <- c(median(fuscoDist$I), IQR(fuscoDist$I)/2)        if(any(is.na(ret))) browser()        return(ret)    }        simulated <- with(obj, replicate(sim.reps, expFun(nInformative + 1, nSpecies)))    simulated <- as.data.frame(t(simulated))    names(simulated) <- c("median", "qd")    sim.twotail <- c((1 - sim.CI)/2, 1 - (1 - sim.CI)/2)    sim.median <- quantile(simulated$median, sim.twotail)    sim.qd <- quantile(simulated$qd, sim.twotail)        ret <- c(obj, list(simulated=simulated, sim.median=sim.median, sim.qd=sim.qd, sim.reps=sim.reps, sim.CI=sim.CI))    class(ret) <- "fusco"        return(ret)}fusco.null.tree <- function(nTips, nSpecies){    # think about this - doesn't guarantee the number    # of informative nodes...        if(nSpecies < nTips){        stop("Fewer species specified than internal nodes + 1")    }    phy <- reorder(rtree(nTips), "pruningwise")    breaks <- sample(1:(nSpecies-1), nTips-1)    rich <- diff(c(0,sort(breaks),nSpecies))        return(list(phy=phy, rich=rich))    }print.fusco <- function(obj, ...){    print(obj$observed)}summary.fusco <- function(obj, ...){    cat("Fusco test for phylogenetic imbalance\n\n")        cat("  Tree with", obj$nInformative, "informative nodes and", obj$nTips, "tips.\n")    if(obj$tipsAsSpecies){        cat("  Tips are treated as species.\n\n")    } else {        cat("  Tips are higher taxa containing", obj$nSpecies, "species.\n")    }        if(! is.null(obj$simulated)){        cat(" ", sprintf("%2.1f%%", obj$sim.CI*100), "confidence intervals simulated using", obj$sim.reps, "replicates.\n" )    }    cat("\n")        cat("  Median I:", round(obj$median,3))    if(! is.null(obj$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  obj$sim.median[1],obj$sim.median[2]))    }    cat("\n")    cat("  Quartile deviation in I:", round(obj$qd,3))    if(! is.null(obj$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  obj$sim.qd[1],obj$sim.qd[2]))    }    cat("\n")        print(wilcox.test(obj$observed$I.prime, mu=0.5))    }plot.fusco <- function(x, correction=TRUE, nBins=10, right=FALSE){            breaks <- seq(0,1,length=nBins+1)    fuscoDist <- hist(x$observed$I, breaks=breaks, plot=FALSE, right=right)    interv <- levels(cut(0.5, breaks=breaks, right=right)) # hijack the interval notation code    RET <- data.frame(imbalance=interv, observedFrequency=fuscoDist$density/nBins)        if(correction==TRUE){        # find out the distribution of possible values for         # each node given the number of classes        allPossI <- function(S){            m <- ceiling(S/2)            return((seq(from=m, to=S-1) - m)/((S - 1) - m))        }        distrib <- sapply(x$observed$S, FUN=allPossI)        distrib <- sapply(distrib, function(x) hist(x, breaks=breaks, plot=FALSE, right=right)$density)        distrib <- distrib/nBins        correction <- 1/nBins - distrib        correction <- rowMeans(correction)                # distrib <- sapply(x$observed$S, FUN=allPossI)        # distrib <- hist(unlist(distrib), breaks=breaks, plot=FALSE)        # correction <- 1/nBins - distrib$density/nBins                RET$correction <- correction        RET$correctedFrequency <- with(RET, observedFrequency + correction)                # hijack the histogram plotting        plot(structure(list(density=RET$correctedFrequency, breaks=breaks),              class="histogram"), freq=FALSE, ylab="Corrected Frequency", main="",             xlab="Imbalance score")        if(! is.null(x$sim.median)) abline(v=x$sim.median, col="red")        abline(v=median(x$observed$I))    } else {        # hijack the histogram plotting        plot(structure(list(density=RET$observedFrequency, breaks=breaks),              class="histogram"), freq=FALSE, ylab="Observed Frequency", main="",             xlab="Imbalance score")        if(! is.null(x$sim.median)) abline(v=x$sim.median, col="red")        abline(v=median(x$observed$I))    }        invisible(RET)    }