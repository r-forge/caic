fusco.test <- function(phy, data = NULL, rich = NULL, names.col = NULL, randomise.Iprime=TRUE,                        markov.simulate=FALSE, reps=1000, conf.int = 0.95){        phy <- reorder(phy, "pruningwise")        if(! is.null(data)){        # match the data in        if(! is.data.frame(data)) stop("The object '", deparse(substitute(data)),"' is not a data frame.")        rich <- deparse(substitute(rich))        if(! rich %in% names(data)) stop("The column '", rich, "' was not found in '", deparse(substitute(data)),",'.")        names.col <- deparse(substitute(names.col))        if(! names.col %in% names(data)) stop("The column '", names.col, "' was not found in '", deparse(substitute(data)),",'.")                       tipMatch <- match(phy$tip.label, data[,names.col])        if(any(is.na(tipMatch))) {            stop(paste(c("Missing species richness values for the following names:",                       phy$tip.label[is.na(tipMatch)]), collapse="\n"))}                rich <- data[tipMatch, rich]        namesAsSpecies <- FALSE    } else {        # assume that the names are species        rich <- rep(1, length(phy$tip.label))        namesAsSpecies <- TRUE    }    observed <- fusco.calc(phy, rich)    obsStats <- with(observed, c(median(I), IQR(I)/2))        ret <- list(observed=observed, median.I=median(observed$I), mean.Iprime=mean(observed$I.prime),                qd=IQR(observed$I)/2, namesAsSpecies=namesAsSpecies,                 nInformative=dim(observed)[1], nSpecies=sum(rich), nTips=length(rich))                    class(ret) <- "fusco"    # kept in as an option mostly through stubbornness    if(markov.simulate){        ret <- fusco.markovSimulate(ret, reps, conf.int)    }        if(randomise.Iprime){        ret <- fusco.randomise(ret, reps, conf.int)    }            return(ret)}fusco.calc <- function(phy, rich){    # OLD TO NEW CONVERTED    # rewritten by David Orme to use less expensive tree traversal    # assumes that fusco.test provides a vector of richnesses in the same tip order    # and that the tree is in pruningwise order        intNodes <- unique(phy$edge[,1])    nTip <- length(phy$tip.label)    nNode <- phy$Nnode    rich <- c(rich, rep(NA, nNode))        # Data store    tab <- data.frame(polytomy=logical(nNode), N1 = numeric(nNode),                      N2 = numeric(nNode), row.names=intNodes)        # loop tips    for(ind in seq(along=intNodes)){                # grab the daughters of the node        daughters <- phy$edge[,2][phy$edge[,1] == intNodes[ind]]        richD <- rich[daughters]                if(length(daughters) > 2){            tab$polytomy[ind] <- TRUE          } else {            tab[ind, 2:3] <- richD        }                rich[intNodes[ind]] <- sum(richD)    }        tab$S <- with(tab, N1 + N2)    tab <- subset(tab, ! polytomy & S > 3, select=-polytomy)        tab$B <- with(tab, pmax(N1, N2))    tab$M <- tab$S - 1    tab$m <- ceiling(tab$S/2)        tab$I <- with(tab, (B - m)/(M - m))    tab$S.odd <- (tab$S %% 2) == 1    tab$w <- with(tab, ifelse(S.odd, 1, ifelse(I > 0, M/S, 2*M/S)))     tab$I.w <- with(tab, (I*w)/mean(w))    tab$I.prime <- with(tab, ifelse(S.odd, I, I * M/S))    return(tab)}  fusco.randomise <- function(object,  rand.reps=1000, rand.CI = 0.95){        expFun <- function(x){    	y <- runif(length(x))    	rand.I.prime <- ifelse(y>0.5,x,1-x)    	ret <- mean(rand.I.prime)    	return(ret)    }    	    randomised <- with(object, replicate(rand.reps, expFun(observed$I.prime)))    randomised <- as.data.frame(randomised)    names(randomised) <- "mean"    rand.twotail <- c((1 - rand.CI)/2, 1 - (1 - rand.CI)/2)    rand.mean <- quantile(randomised$mean, rand.twotail)        ret <- c(object, list(randomised=randomised, rand.mean=rand.mean, reps=rand.reps, conf.int=rand.CI))    class(ret) <- "fusco"        return(ret)}fusco.markovSimulate <- function(object,  sim.reps=1000, sim.CI = 0.95){        # Think about which version of I to use    expFun <- function(nTips, nSpp){        nullTree <- fusco.markovNullTree(nTips, nSpp)        fuscoDist <- with(nullTree, fusco.calc(phy, rich))        ret <- c(median(fuscoDist$I), IQR(fuscoDist$I)/2)        if(any(is.na(ret))) browser()        return(ret)    }        simulated <- with(object, replicate(sim.reps, expFun(nInformative + 1, nSpecies)))    simulated <- as.data.frame(t(simulated))    names(simulated) <- c("median", "qd")    sim.twotail <- c((1 - sim.CI)/2, 1 - (1 - sim.CI)/2)    sim.median <- quantile(simulated$median, sim.twotail)    sim.qd <- quantile(simulated$qd, sim.twotail)        ret <- c(object, list(simulated=simulated, sim.median=sim.median, sim.qd=sim.qd, reps=sim.reps, conf.int=sim.CI))    class(ret) <- "fusco"        return(ret)}fusco.markovNullTree <- function(nTips, nSpecies){    # think about this - doesn't guarantee the number    # of informative nodes...        if(nSpecies < nTips){        stop("Fewer species specified than internal nodes + 1")    }    phy <- reorder(rtree(nTips), "pruningwise")    breaks <- sample(1:(nSpecies-1), nTips-1)    rich <- diff(c(0,sort(breaks),nSpecies))        return(list(phy=phy, rich=rich))    }print.fusco <- function(x, ...){    print(x$observed)}summary.fusco <- function(object, ...){    cat("Fusco test for phylogenetic imbalance\n\n")        cat("  Tree with", object$nInformative, "informative nodes and", object$nTips, "tips.\n")    if(object$namesAsSpecies){        cat("  Tips are treated as species.\n\n")    } else {        cat("  Tips are higher taxa containing", object$nSpecies, "species.\n")    }        if(! is.null(object$randomised) | ! is.null(object$simulated)){        cat(" ", sprintf("%2.1f%%", object$conf.int*100), "confidence intervals randomised or simulated using", object$reps, "replicates.\n" )    }    cat("\n")    cat("  Mean I prime:", round(object$mean.Iprime,3))    if(! is.null(object$randomised)){        cat(sprintf(" [%1.3f,%1.3f]",  object$rand.mean[1],object$rand.mean[2]))    }    cat("\n")        cat("  Median I:", round(object$median.I,3))    if(! is.null(object$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  object$sim.median[1],object$sim.median[2]))    }    cat("\n")    cat("  Quartile deviation in I:", round(object$qd,3))    if(! is.null(object$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  object$sim.qd[1],object$sim.qd[2]))    }    cat("\n")        print(wilcox.test(object$observed$I.prime, mu=0.5))    }plot.fusco <- function(x, correction=TRUE, nBins=10, right=FALSE, I.prime=TRUE, ...){            breaks <- seq(0,1,length=nBins+1)    if(I.prime){        fuscoDist <- hist(x$observed$I.prime, breaks=breaks, plot=FALSE, right=right)        xLab <- "Nodal imbalance score (I')"    } else {        fuscoDist <- hist(x$observed$I, breaks=breaks, plot=FALSE, right=right)                xLab <- "Nodal imbalance score (I)"    }        interv <- levels(cut(0.5, breaks=breaks, right=right)) # hijack the interval notation code    RET <- data.frame(imbalance=interv, observedFrequency=fuscoDist$density/nBins)        if(correction==TRUE){        # find out the distribution of possible values for         # each node given the number of classes        allPossI <- function(S, I.prime){            m <- ceiling(S/2)            RET <- (seq(from=m, to=S-1) - m)/((S - 1) - m)            if(I.prime & (S%%2) == 1) RET <- RET * (S-1) / S            return(RET)        }                distrib <- sapply(x$observed$S, FUN=allPossI, I.prime=I.prime)        distrib <- sapply(distrib, function(x) hist(x, breaks=breaks, plot=FALSE, right=right)$density)        distrib <- distrib/nBins        correction <- 1/nBins - distrib        correction <- rowMeans(correction)                # distrib <- sapply(x$observed$S, FUN=allPossI)        # distrib <- hist(unlist(distrib), breaks=breaks, plot=FALSE)        # correction <- 1/nBins - distrib$density/nBins                RET$correction <- correction        RET$correctedFrequency <- with(RET, observedFrequency + correction)                # hijack the histogram plotting        plot(structure(list(density=RET$correctedFrequency, breaks=breaks),              class="histogram"), freq=FALSE, ylab="Corrected Frequency", main="",             xlab=xLab)    } else {        # hijack the histogram plotting        plot(structure(list(density=RET$observedFrequency, breaks=breaks),              class="histogram"), freq=FALSE, ylab="Observed Frequency", main="",             xlab=xLab)    }        if(I.prime){        abline(v=x$mean.Iprime)        if(! is.null(x$rand.mean)) abline(v=x$rand.mean, col="red")            } else {        abline(v=median(x$observed$I))        if(! is.null(x$sim.median)) abline(v=x$sim.median, col="red")    }    invisible(RET)    }